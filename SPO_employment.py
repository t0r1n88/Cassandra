"""
Скрипт для подсчета показателей трудоустройства выпускников
"""

import pandas as pd
import os
import openpyxl


def create_low_dct():
    """
    Функция для создания словаря низкого уровня вида 8 ключей:{23 ключа:0}
    :return: Словарь нужной структуры
    """
    # Создаем базовые структы данных
    # Список категорий по которым будет идти подсчет

    # ахаха особенности оформления документа что ключи придется писать так как они там написаны т.е. вот с такими пробелами
    base_cat = ['Всего ', 'Лица с ограниченными возможностями здоровья',
                '           из них (из строки 02): инвалиды и дети-инвалиды',
                'Инвалиды и дети-инвалиды (кроме учтенных в строке 03)',
                'Имеют договор о целевом обучении',
                '           из них (из строки 05): Лица с ограниченными возможностями здоровья (имеющие договор о целевом обучении)',
                '                      из строки 06: инвалиды и дети-инвалиды (имеющие договор о целевом обучении)',
                '           из строки 05 инвалиды и дети-инвалиды (кроме учтенных в строке 07) (имеющие договор о целевом обучении)']

    # Вот это словарь жутковато выглядит.Словарь показателей
    base_dct = {'Выпуск в 2021': 0, 'Трудоустроено человек': 0, 'Индивидуальные предприниматели': 0, 'Самозанятые': 0,
                'Призваны в Вооруженные силы': 0, 'Продолжили обучение': 0,
                'Находятся в отпуске по уходу за ребенком': 0,
                'Находящиеся под риском нетрудоустройства ': 0,
                'в том числе (из гр. 22): состоят на учете в центрах занятости в качестве ищущих работу или безработных': 0,
                'Прочее: смерть, переезд за пределы Российской Федерации, семейные обстоятельства, по состоянию здоровья и др.***': 0,
                'перечислить причины, указав число человек': '',
                'Не определились (ожидают результатов приемной кампании, ожидают призыва, находятся в активном поиске работы, собирают документы для открытия ИП. Выпускники временно не заняты, но их занятости ничего не угрожает)': 0,
                'Прогноз Трудоустройство': 0, 'Прогноз Индивидуальные предприниматели': 0, 'Прогноз Самозанятые': 0,
                'Прогноз Продолжили обучение': 0, 'Прогноз Призваны в Вооруженные силы': 0,
                'Прогноз Находятся в отпуске по уходу за ребенком': 0,
                'Прогноз Находящиеся под риском нетрудоустройства выпускники ': 0,
                'Прогноз в том числе (из гр. 42): состоят на учете в центрах занятости в качестве ищущих работу или безработных': 0,
                'Прогноз Прочее: смерть, переезд за пределы Российской Федерации, семейные обстоятельства, по состоянию здоровья и др.*** ': 0,
                'Прогноз перечислить причины': '',
                'Причины, по которым выпускники находятся под риском нетрудоустройства, и принимаемые меры (тезисно)': ''}

    # Создаем словарь нижнего уровня
    temp_dct = {key: base_dct for key in base_cat}
    return temp_dct










# Открываем лист со списком СПО, с опцией для чтения чтобы ускорить процесс
temp = openpyxl.load_workbook('data/SPO.xlsx',read_only=True)
#Получаем список листов
sheets = temp.sheetnames
# Закрываем лист после чтения
temp.close()

# Создаем словарь верхнего уровня

high_dct = dict.fromkeys(sheets,dict())

# Открываем файл с указанным листом и сохраняем его в датафрейм пропуская  первые 8 строк
for sheet in sheets:
    if sheet not in('Форма 1','Форма 2','Коды и наименования программ'):
        df = pd.read_excel('data/SPO.xlsx',sheet_name=sheet,skiprows=8,dtype={'Код профессии, специальности*':str})

        # Создаем список специальность которые есть на данном листе
        codes_spec = df['04'].unique()
        # Создаем словарь через comprehnsions
        # Отбираем только строковые, отбрасывая ключ nan. В качестве значения присваиваем копию словаря низкого уровня
        # Забыл про ссылочную модель и не мог долго понять почему значения дублируются
        spec_code_dct = {code:create_low_dct() for code in codes_spec if type(code) == str }

        # Присваиваем полученный словарь со специальностями словарю high_dct
        """
        В итоге получается такая струтура {'КТИНЗ': {'29.01.07': {}, '35.01.23': {}, '43.01.09': {}, '54.01.06': {}, '54.01.03': {}, '35.02.07': {}, '54.02.02': {}}, 'ТСГХ': {}, 'БФКК': {}}
        """
        print(id(spec_code_dct))
        high_dct[sheet] = spec_code_dct
        print(id(high_dct[sheet]))
        # Итерируемся по полученному датафрейму через itertuples
        for row in df.itertuples():
            # Получаем код специальности для итерируемой строки. Отбрасываем пустые строки, просто проверяя есть ли такой ключ в главном словаре
            row_code = row[4]
            if row_code in high_dct[sheet]:
                # КТИНЗ:35.01.23:
                # print(high_dct[sheet][row_code])
                cat = row[6]

                # high_dct[sheet][row_code][cat]['Выпуск в 2021'] = row[7]
                # high_dct[sheet][row_code][cat]['Трудоустроено человек'] = row[8]







print(high_dct['КТИНЗ']['35.01.23']['Всего '])
print(high_dct['КТИНЗ']['35.01.23']['Лица с ограниченными возможностями здоровья'])
print('****************')
print(high_dct['ТСГХ']['08.01.14']['Всего '])


